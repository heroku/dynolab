// +build linux

package main

import (
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"os"
	"strings"
	"syscall"
	"text/template"
	"unsafe"

	libseccomp "github.com/seccomp/libseccomp-golang"
	"golang.org/x/sys/unix"

	"github.com/heroku/dynolab/seccomp"
)

var (
	out     = flag.String("o", "", "output file")
	pkg     = flag.String("pkg", "seccomp", "package name")
	varName = flag.String("var", "prog", "variable name")
)

func main() {
	flag.Parse()
	if *out == "" {
		log.Fatal("missing -o argument")
	}

	filter, err := libseccomp.NewFilter(libseccomp.ActAllow)
	if err != nil {
		log.Fatal(err)
	}

	for _, syscall := range seccomp.BlockedSyscalls {
		if err := filter.AddRule(libseccomp.ScmpSyscall(syscall), libseccomp.ActErrno.SetReturnCode(int16(unix.EPERM))); err != nil {
			log.Fatal(err)
		}
	}

	tmpPFC, err := ioutil.TempFile("", "prog.pfc")
	if err != nil {
		log.Fatal(err)
	}
	if err := filter.ExportPFC(tmpPFC); err != nil {
		log.Fatal(err)
	}
	if _, err := tmpPFC.Seek(0, 0); err != nil {
		log.Fatal(err)
	}

	tmpBPF, err := ioutil.TempFile("", "prog.bpf")
	if err != nil {
		log.Fatal(err)
	}
	if err := filter.ExportBPF(tmpBPF); err != nil {
		log.Fatal(err)
	}
	if _, err := tmpBPF.Seek(0, 0); err != nil {
		log.Fatal(err)
	}

	pfc, err := ioutil.ReadAll(tmpPFC)
	if err != nil {
		log.Fatal(err)
	}
	pfc = pfc[:len(pfc)-1]

	bpf, err := ioutil.ReadAll(tmpBPF)
	if err != nil {
		log.Fatal(err)
	}

	lenBPF := len(bpf)
	encodedBPF := fmt.Sprintf("%#v\n", bpf)
	progLen := lenBPF / int(unsafe.Sizeof(syscall.SockFilter{}))

	data := struct {
		Package         string
		ProgLen         int
		PFC, EncodedBPF string
		VarName         string
	}{
		Package:    *pkg,
		ProgLen:    progLen,
		PFC:        strings.Replace(string(pfc), "\n", "\n\t", -1),
		EncodedBPF: encodedBPF,
		VarName:    *varName,
	}

	var w io.Writer = os.Stdout
	if *out != "" {
		if w, err = os.Create(*out); err != nil {
			log.Fatal(err)
		}
	}

	if err := tmpl.Execute(w, data); err != nil {
		log.Fatal(err)
	}
}

var tmpl = template.Must(template.New("output.go").Parse(`// Code generated by github.com/heroku/dynolab/seccomp/generate. DO NOT EDIT.

package {{ .Package }}

import (
	"syscall"
	"unsafe"
)

func init() {
	{{ .VarName }} = &syscall.SockFprog{
		Len:    {{ .ProgLen }},
		Filter: (*syscall.SockFilter)(unsafe.Pointer(&{{ .VarName }}Data[0])),
	}
}

/*
	{{ .PFC }}
*/

// {{ .VarName }}Data is the BFP program data.
var {{ .VarName }}Data = {{ .EncodedBPF }}`))
